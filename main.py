# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'app.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QFileDialog, QSpinBox, QLabel, QMessageBox

import numpy as np
from fractions import Fraction
from fpdf import FPDF
import random
import subprocess


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(578, 439)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        self.comboBox = QtWidgets.QComboBox(self.centralwidget)
        self.comboBox.setGeometry(QtCore.QRect(200, 40, 321, 31))
        self.comboBox.setObjectName("comboBox")
        self.comboBox.addItem("")
        self.comboBox.addItem("")

        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(40, 40, 101, 31))
        self.label.setObjectName("label")

        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(40, 110, 251, 31))
        self.label_2.setObjectName("label_2")

        '''self.lineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit.setGeometry(QtCore.QRect(340, 110, 181, 31))
        self.lineEdit.setObjectName("lineEdit")'''

        self.spinBox_vars = QSpinBox(self.centralwidget)
        self.spinBox_vars.setGeometry(QtCore.QRect(340, 110, 181, 31))
        self.spinBox_vars.setObjectName("spinBoxVars")
        self.spinBox_vars.setMinimum(1)
        self.spinBox_vars.setMaximum(100)

        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(40, 180, 151, 31))
        self.label_3.setObjectName("label_3")

        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(460, 180, 61, 31))
        self.pushButton.setObjectName("pushButton")

        self.lineEdit_2 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_2.setGeometry(QtCore.QRect(240, 180, 221, 31))
        self.lineEdit_2.setObjectName("lineEdit_2")

        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_2.setGeometry(QtCore.QRect(185, 350, 200, 31))
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton_2.setVisible(False)

        self.label_4 = QtWidgets.QLabel(self.centralwidget)
        self.label_4.setGeometry(QtCore.QRect(40, 250, 300, 31))
        self.label_4.setObjectName("label_4")
        self.label_4.setText(
            "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Размер матрицы перехода:</span></p></body></html>")
        #self.label_4.setVisible(False)

        self.spinBox = QSpinBox(self.centralwidget)
        self.spinBox.setGeometry(QtCore.QRect(441, 250, 80, 31))
        self.spinBox.setObjectName("spinBox")
        self.spinBox.setMinimum(2)
        self.spinBox.setMaximum(10)
        #self.spinBox.setVisible(False)

        self.label_5 = QLabel(self.centralwidget)
        self.label_5.setGeometry(QtCore.QRect(40, 250, 100, 31))
        self.label_5.setObjectName("label_5")
        self.label_5.setText(
            "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Столбцы:</span></p></body></html>")
        self.label_5.setVisible(False)

        self.columnsSpinBox = QSpinBox(self.centralwidget)
        self.columnsSpinBox.setGeometry(QtCore.QRect(200, 250, 50, 31))
        self.columnsSpinBox.setObjectName("columnsSpinBox")
        self.columnsSpinBox.setMinimum(2)
        self.columnsSpinBox.setMaximum(10)
        self.columnsSpinBox.setVisible(False)

        self.label_6 = QLabel(self.centralwidget)
        self.label_6.setGeometry(QtCore.QRect(311, 250, 100, 31))
        self.label_6.setObjectName("label_6")
        self.label_6.setText(
            "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Строки:</span></p></body></html>")
        self.label_6.setVisible(False)

        self.rowsSpinBox = QSpinBox(self.centralwidget)
        self.rowsSpinBox.setGeometry(QtCore.QRect(471, 250, 50, 31))
        self.rowsSpinBox.setObjectName("rowsSpinBox")
        self.rowsSpinBox.setMinimum(2)
        self.rowsSpinBox.setMaximum(10)
        self.rowsSpinBox.setVisible(False)

        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.pushButton.clicked.connect(self.browse_folder)
        self.comboBox.currentIndexChanged.connect(self.on_combobox_changed)

        self.spinBox_vars.textChanged.connect(self.check_fields)
        self.lineEdit_2.textChanged.connect(self.check_fields)
        self.spinBox.valueChanged.connect(self.check_fields)
        self.columnsSpinBox.valueChanged.connect(self.check_fields)
        self.rowsSpinBox.valueChanged.connect(self.check_fields)

        self.pushButton_2.clicked.connect(self.run_task)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Генератор задач"))
        self.comboBox.setItemText(0, _translate("MainWindow", "Задача стационарного распределения"))
        self.comboBox.setItemText(1, _translate("MainWindow", "Задача динамического программирования"))
        self.label.setText(_translate("MainWindow",
                                      "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Задача:</span></p></body></html>"))
        self.label_2.setText(_translate("MainWindow",
                                        "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Количество вариантов:</span></p></body></html>"))
        self.label_3.setText(_translate("MainWindow",
                                        "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Директория:</span></p></body></html>"))
        self.pushButton.setText(_translate("MainWindow", "Browse"))
        self.pushButton_2.setText(_translate("MainWindow", "OK"))

    def browse_folder(self):
        directory = QFileDialog.getExistingDirectory(None, "Select Directory")
        if directory:
            self.lineEdit_2.setText(directory)

    def on_combobox_changed(self):
        task = self.comboBox.currentText()
        if task == "Задача стационарного распределения":
            self.label_4.setVisible(True)
            self.spinBox.setVisible(True)
            self.label_5.setVisible(False)
            self.columnsSpinBox.setVisible(False)
            self.label_6.setVisible(False)
            self.rowsSpinBox.setVisible(False)
        elif task == "Задача динамического программирования":
            self.label_4.setVisible(False)
            self.spinBox.setVisible(False)
            self.label_5.setVisible(True)
            self.columnsSpinBox.setVisible(True)
            self.label_6.setVisible(True)
            self.rowsSpinBox.setVisible(True)
        else:
            self.label_4.setVisible(False)
            self.spinBox.setVisible(False)
            self.label_5.setVisible(False)
            self.columnsSpinBox.setVisible(False)
            self.label_6.setVisible(False)
            self.rowsSpinBox.setVisible(False)
        self.check_fields()

    def check_fields(self):
        task = self.comboBox.currentText()
        if task == "Задача стационарного распределения":
            if self.spinBox_vars.value() > 0 and self.lineEdit_2.text() and self.spinBox.value() > 0:
                self.pushButton_2.setVisible(True)
            else:
                self.pushButton_2.setVisible(False)
        elif task == "Задача динамического программирования":
            if self.spinBox_vars.value() > 0 and self.lineEdit_2.text() and self.columnsSpinBox.value() > 0 and self.rowsSpinBox.value() > 0:
                self.pushButton_2.setVisible(True)
            else:
                self.pushButton_2.setVisible(False)
        else:
            self.pushButton_2.setVisible(False)

    def show_message_box(self, text):
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Information)
        msg.setText(text)
        msg.setWindowTitle("Сообщение")
        msg.setStandardButtons(QMessageBox.Ok)
        msg.exec_()

    def run_task(self):
        task = self.comboBox.currentText()
        if task == "Задача стационарного распределения":
            size = self.spinBox.value()
            num_variants = self.spinBox_vars.value()
            directory = self.lineEdit_2.text()
            matrices = save_matrices_to_pdf(num_variants, size, directory)
            save_distributions_to_pdf(matrices, directory)
            save_matrices_to_tex(num_variants, size, matrices, directory)
            save_distributions_to_tex(num_variants, size, matrices, directory)
        elif task == "Задача динамического программирования":
            n = self.rowsSpinBox.value()
            m = self.columnsSpinBox.value()
            directory = self.lineEdit_2.text()
            M = self.spinBox_vars.value()  # Number of variants
            variants = [generate_numbers(n, m) for _ in range(M)]
            solutions = [max_probability_allocation(n, m, variant) for variant in variants]
            latex_content_without_solution = create_latex_document(variants, solutions, n, m, with_solution=False)
            save_latex_file(f"{directory}/tasks_only.tex", latex_content_without_solution)
            compile_latex_to_pdf(f"{directory}/tasks_only.tex", directory)
            latex_content_with_solution = create_latex_document(variants, solutions, n, m, with_solution=True)
            save_latex_file(f"{directory}/tasks_with_solutions.tex", latex_content_with_solution)
            compile_latex_to_pdf(f"{directory}/tasks_with_solutions.tex", directory)

        self.show_message_box(text="Файлы успешно сгенерированы")


'''Stationary Distribution'''


def generate_random_fraction_matrix(size, denominator=20):
    matrix = np.zeros((size, size), dtype=object)

    for i in range(size):
        random_points = sorted(np.random.choice(range(1, denominator), size - 1, replace=False))
        numerators = [random_points[0]] + [random_points[j] - random_points[j-1] for j in range(1, size - 1)] + [denominator - random_points[-1]]

        row = [Fraction(num, denominator) for num in numerators]
        matrix[i] = row

    return matrix


def find_stationary_distribution(P, max_denominator=20):
    size = len(P)
    P_float = np.array(P, dtype=float)
    A = P_float.T - np.eye(size)
    A = np.vstack([A, np.ones(size)])
    b = np.zeros(size + 1)
    b[-1] = 1

    pi = np.linalg.lstsq(A, b, rcond=None)[0]
    stationary_vector = [Fraction.from_float(v).limit_denominator() for v in pi]

    return stationary_vector


def save_matrices_to_pdf(num_variants, size, directory, max_denominator=20):
    pdf = FPDF()
    pdf.add_page()
    pdf.add_font("DejaVu", "", "font/DejavuSans.ttf", uni=True)
    pdf.set_font("DejaVu", size=12)

    matrices = []

    for i in range(num_variants):
        P = generate_random_fraction_matrix(size, denominator=20)
        matrices.append(P)
        pdf.cell(200, 10, text=f"Вариант # {i+1}", new_x="LMARGIN", new_y="NEXT")
        pdf.multi_cell(200, 10, text="Найти стационарное распределение однородной цепи Маркова в дискретном времени с матрицей перехода", new_x="LMARGIN", new_y="NEXT")
        for row in P:
            row_text = ' '.join([str(elem) for elem in row])
            pdf.cell(200, 10, text=row_text, new_x="LMARGIN", new_y="NEXT")
        pdf.cell(200, 10, text="", new_x="LMARGIN", new_y="NEXT")
        pdf.cell(0, 10, "", new_x="LMARGIN", new_y="NEXT", border='B')

    pdf.output(f"{directory}/transition_matrices.pdf")
    return matrices


def save_distributions_to_pdf(matrices, directory, max_denominator=20):
    pdf = FPDF()
    pdf.add_page()
    pdf.add_font("DejaVu", "", "font/DejavuSans.ttf", uni=True)
    pdf.set_font("DejaVu", size=12)

    for i, P in enumerate(matrices):
        pi = find_stationary_distribution(P, max_denominator=max_denominator)
        pdf.cell(200, 10, text=f"Вариант # {i+1}", new_x="LMARGIN", new_y="NEXT")
        pdf.cell(200, 10, text=f"Стационарное распределение:", new_x="LMARGIN", new_y="NEXT")
        pi_text = ' '.join([str(elem) for elem in pi])
        pdf.cell(200, 10, text=pi_text, new_x="LMARGIN", new_y="NEXT")
        pdf.cell(200, 10, text="", new_x="LMARGIN", new_y="NEXT")

    pdf.output(f"{directory}/transition_matrices_with_distributions.pdf")


def save_matrices_to_tex(num_variants, size, matrices, directory):
    with open(f"{directory}/transition_matrices.tex", "w") as f:
        f.write(r"\documentclass{article}" + "\n")
        f.write(r"\usepackage[utf8]{inputenc}" + "\n")
        f.write(r"\usepackage[russian]{babel}" + "\n")
        f.write(r"\usepackage{amsmath}" + "\n")
        f.write(r"\begin{document}" + "\n")

        for i in range(num_variants):
            P = matrices[i]
            f.write(f"\\section*{{Вариант # {i+1}}}\n")
            f.write("Найти стационарное распределение однородной цепи Маркова в дискретном времени с матрицей перехода:\n")
            f.write("\\begin{equation}\n")
            f.write("\\left( \\begin{array}{" + "c" * size + "}\n")
            for row in P:
                row_text = ' & '.join([str(elem) for elem in row])
                f.write(row_text + r" \\" + "\n")
            f.write("\\end{array} \\right)\n")
            f.write("\\end{equation}\n")
            f.write("\\noindent\\rule{\\textwidth}{0.4pt}\n")

        f.write(r"\end{document}" + "\n")


def save_distributions_to_tex(num_variants, size, matrices, directory):
    with open(f"{directory}/transition_matrices_with_distributions.tex", "w") as f:
        f.write(r"\documentclass{article}" + "\n")
        f.write(r"\usepackage[utf8]{inputenc}" + "\n")
        f.write(r"\usepackage[russian]{babel}" + "\n")
        f.write(r"\usepackage{amsmath}" + "\n")
        f.write(r"\begin{document}" + "\n")

        for i in range(num_variants):
            P = matrices[i]
            pi = find_stationary_distribution(P)
            f.write(f"\\section*{{Вариант # {i+1}}}\n")
            f.write("\\noindent Стационарное распределение:\\\\\n")
            f.write("\\begin{equation}\n")
            f.write(" \\left( \\begin{array}{c}\n")
            pi_text = '\quad'.join([str(elem) for elem in pi])
            f.write(pi_text + r" \\" + "\n")
            f.write("\\end{array} \\right)\n")
            f.write("\\end{equation}\n")
            f.write("\\noindent\\rule{\\textwidth}{0.4pt}\n")

        f.write(r"\end{document}" + "\n")


'''Dynamic Programming'''


def generate_numbers(n, m):
    numbers = []
    for i in range(n):
        sequence = sorted([round(random.uniform(0, 1), 1) for _ in range(m)], reverse=True)
        numbers.extend(sequence)
    return numbers


def max_probability_allocation(n, m, probabilities):
    num_machines = m
    num_companies = n
    probabilities = np.array(probabilities).reshape(num_companies, num_machines)
    dp = np.zeros((num_companies + 1, num_machines + 1))
    dp[0, 0] = 1
    choices = [[[] for _ in range(num_machines + 1)] for _ in range(num_companies + 1)]
    for i in range(1, num_companies + 1):
        for j in range(num_machines + 1):
            for k in range(min(j, num_machines) + 1):
                prob = dp[i - 1, j - k] * (probabilities[i - 1, k - 1] if k > 0 else 1)
                if prob > dp[i, j]:
                    dp[i, j] = prob
                    choices[i][j] = [[k]]
                elif prob == dp[i, j]:
                    choices[i][j].append([k])

    def get_all_allocations(i, j):
        if i == 0:
            return [[]]
        all_paths = []
        for choice in choices[i][j]:
            sub_paths = get_all_allocations(i - 1, j - choice[0])
            for sub_path in sub_paths:
                all_paths.append(sub_path + choice)
        return all_paths

    all_allocations = get_all_allocations(num_companies, num_machines)
    unique_allocations = []
    for alloc in all_allocations:
        if alloc not in unique_allocations:
            unique_allocations.append(alloc)
    solution_text = ""
    solution_text += "Матрица вероятностей:\n"
    solution_text += str(probabilities)
    solution_text += "\n\nОптимальные распределения машин по каждой компании (в порядке от первой до последней):\n"
    for alloc in unique_allocations:
        solution_text += str(alloc) + "\n"
    solution_text += f"\nМаксимальная вероятность выполнения заказа: {dp[num_companies, num_machines]:.5f}\n"
    return solution_text


def create_latex_table(numbers, n, m):
    latex = "\\begin{center}\n"
    latex += "\\begin{tabular}{|" + "c|" * (m + 1) + "}\n"
    latex += "\\hline\n"
    headers = " & " + " & ".join([str(i + 1) for i in range(m)]) + " \\\\ \\hline\n"
    latex += headers
    for i in range(n):
        row = " & ".join(map(str, numbers[i * m:(i + 1) * m])) + f" \\\\ \\hline\n"
        latex += f"$P_{{{i + 1}}}$ & " + row
    latex += "\\end{tabular}\n"
    latex += "\\end{center}\n"
    return latex


def create_latex_document(variants, solutions, n, m, with_solution=False):
    latex = "\\documentclass{article}\n"
    latex += "\\usepackage[utf8]{inputenc}\n"
    latex += "\\usepackage[russian]{babel}\n"
    latex += "\\usepackage{geometry}\n"
    latex += "\\usepackage{amsmath}\n"
    latex += "\\usepackage{graphicx}\n"
    latex += "\\geometry{a4paper, margin=1in}\n"
    latex += "\\begin{document}\n"
    for i, numbers in enumerate(variants):
        latex += f"\\section*{{Вариант № {i + 1}}}\n"
        latex += f"Срочный заказ по изготовлению {m} машин необходимо разместить между {n} предприятиями. "
        latex += f"Вероятности выполнения заказа $k$-ым предприятием равны $P_k$ (где $k$ - это индекс) зависят от величины заказа и заданы таблицей.\n"
        latex += create_latex_table(numbers, n, m)
        latex += f"\nНайти оптимальный план размещения заказа, при котором достигает максимум вероятность $P$ выполнения заказа всеми предприятиями.\n"
        if with_solution:
            latex += "\n\\textbf{Решение:}\n"
            latex += solutions[i].replace("\n", "\\newline\n")
        if i < len(variants) - 1:
            latex += "\\newpage\n"
    latex += "\\end{document}\n"
    return latex


def save_latex_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(content)


def compile_latex_to_pdf(latex_filename, output_directory):
    result = subprocess.run(["pdflatex", f"-output-directory={output_directory}", latex_filename], capture_output=True, text=True)
    if result.returncode != 0:
        print("Error during LaTeX compilation:")
        print(result.stderr)
        with open("error.log", 'w') as f:
            f.write(result.stderr)
    else:
        print("PDF file created successfully.")


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())

