# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'app.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QFileDialog, QSpinBox, QLabel, QMessageBox, QCheckBox

import numpy as np
from fractions import Fraction
from fpdf import FPDF
import random
import subprocess
from collections import defaultdict
from scipy.optimize import minimize


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(578, 439)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        self.comboBox = QtWidgets.QComboBox(self.centralwidget)
        self.comboBox.setGeometry(QtCore.QRect(200, 40, 321, 31))
        self.comboBox.setObjectName("comboBox")
        self.comboBox.addItem("")
        self.comboBox.addItem("")
        self.comboBox.addItem("")

        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(40, 40, 101, 31))
        self.label.setObjectName("label")

        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(40, 110, 251, 31))
        self.label_2.setObjectName("label_2")

        '''self.lineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit.setGeometry(QtCore.QRect(340, 110, 181, 31))
        self.lineEdit.setObjectName("lineEdit")'''

        self.spinBox_vars = QSpinBox(self.centralwidget)
        self.spinBox_vars.setGeometry(QtCore.QRect(340, 110, 181, 31))
        self.spinBox_vars.setObjectName("spinBoxVars")
        self.spinBox_vars.setMinimum(1)
        self.spinBox_vars.setMaximum(100)

        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(40, 180, 151, 31))
        self.label_3.setObjectName("label_3")

        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(460, 180, 61, 31))
        self.pushButton.setObjectName("pushButton")

        self.lineEdit_2 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_2.setGeometry(QtCore.QRect(240, 180, 221, 31))
        self.lineEdit_2.setObjectName("lineEdit_2")

        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_2.setGeometry(QtCore.QRect(321, 350, 200, 31))
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton_2.setVisible(False)

        self.label_4 = QtWidgets.QLabel(self.centralwidget)
        self.label_4.setGeometry(QtCore.QRect(40, 250, 300, 31))
        self.label_4.setObjectName("label_4")
        self.label_4.setText(
            "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Размер матрицы перехода:</span></p></body></html>")
        #self.label_4.setVisible(False)

        self.spinBox = QSpinBox(self.centralwidget)
        self.spinBox.setGeometry(QtCore.QRect(441, 250, 80, 31))
        self.spinBox.setObjectName("spinBox")
        self.spinBox.setMinimum(2)
        self.spinBox.setMaximum(10)
        #self.spinBox.setVisible(False)

        self.label_5 = QLabel(self.centralwidget)
        self.label_5.setGeometry(QtCore.QRect(40, 250, 220, 31))
        self.label_5.setObjectName("label_5")
        self.label_5.setText(
            "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Кол-во предприятий</span></p></body></html>")
        self.label_5.setVisible(False)

        self.columnsSpinBox = QSpinBox(self.centralwidget)
        self.columnsSpinBox.setGeometry(QtCore.QRect(255, 250, 50, 31))
        self.columnsSpinBox.setObjectName("columnsSpinBox")
        self.columnsSpinBox.setMinimum(2)
        self.columnsSpinBox.setMaximum(10)
        self.columnsSpinBox.setVisible(False)

        self.label_6 = QLabel(self.centralwidget)
        self.label_6.setGeometry(QtCore.QRect(321, 250, 150, 31))
        self.label_6.setObjectName("label_6")
        self.label_6.setText(
            "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Кол-во машин</span></p></body></html>")
        self.label_6.setVisible(False)

        self.rowsSpinBox = QSpinBox(self.centralwidget)
        self.rowsSpinBox.setGeometry(QtCore.QRect(471, 250, 50, 31))
        self.rowsSpinBox.setObjectName("rowsSpinBox")
        self.rowsSpinBox.setMinimum(2)
        self.rowsSpinBox.setMaximum(10)
        self.rowsSpinBox.setVisible(False)

        self.PDF2CheckBox = QCheckBox(self.centralwidget)
        self.PDF2CheckBox.setGeometry(QtCore.QRect(40, 300, 200, 31))
        self.PDF2CheckBox.setObjectName("PDFCheckBox")
        self.PDF2CheckBox.setText("Сгенерировать PDF файлы")
        self.PDF2CheckBox.setVisible(False)

        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.pushButton.clicked.connect(self.browse_folder)
        self.comboBox.currentIndexChanged.connect(self.on_combobox_changed)

        self.spinBox_vars.textChanged.connect(self.check_fields)
        self.lineEdit_2.textChanged.connect(self.check_fields)
        self.spinBox.valueChanged.connect(self.check_fields)
        self.columnsSpinBox.valueChanged.connect(self.check_fields)
        self.rowsSpinBox.valueChanged.connect(self.check_fields)

        self.pushButton_2.clicked.connect(self.run_task)

        self.label_7 = QLabel(self.centralwidget)
        self.label_7.setGeometry(QtCore.QRect(40, 250, 300, 31))
        self.label_7.setObjectName("label_7")
        self.label_7.setText(
            "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Размер матрицы N:</span></p></body></html>")
        self.label_7.setVisible(False)

        self.spinBox_N = QSpinBox(self.centralwidget)
        self.spinBox_N.setGeometry(QtCore.QRect(441, 250, 80, 31))
        self.spinBox_N.setObjectName("spinBox_N")
        self.spinBox_N.setMinimum(2)
        self.spinBox_N.setMaximum(100)
        self.spinBox_N.setVisible(False)

        self.label_eps = QLabel(self.centralwidget)
        self.label_eps.setGeometry(QtCore.QRect(40, 300, 150, 31))
        self.label_eps.setObjectName("label_eps")
        self.label_eps.setText(
            "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Eps:</span></p></body></html>")
        self.label_eps.setVisible(False)

        self.lineEdit_eps = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_eps.setGeometry(QtCore.QRect(90, 300, 40, 31))
        self.lineEdit_eps.setObjectName("lineEdit_eps")
        self.lineEdit_eps.setVisible(False)

        self.label_beta = QLabel(self.centralwidget)
        self.label_beta.setGeometry(QtCore.QRect(140, 300, 150, 31))
        self.label_beta.setObjectName("label_beta")
        self.label_beta.setText(
            "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Beta:</span></p></body></html>")
        self.label_beta.setVisible(False)

        self.lineEdit_beta = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_beta.setGeometry(QtCore.QRect(200, 300, 40, 31))
        self.lineEdit_beta.setObjectName("lineEdit_beta")
        self.lineEdit_beta.setVisible(False)

        self.label_lambda = QLabel(self.centralwidget)
        self.label_lambda.setGeometry(QtCore.QRect(250, 300, 150, 31))
        self.label_lambda.setObjectName("label_lambda")
        self.label_lambda.setText(
            "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Lambda:</span></p></body></html>")
        self.label_lambda.setVisible(False)

        self.lineEdit_lambda = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_lambda.setGeometry(QtCore.QRect(345, 300, 40, 31))
        self.lineEdit_lambda.setObjectName("lineEdit_lambda")
        self.lineEdit_lambda.setVisible(False)

        self.PDF3CheckBox = QCheckBox(self.centralwidget)
        self.PDF3CheckBox.setGeometry(QtCore.QRect(40, 350, 200, 31))
        self.PDF3CheckBox.setObjectName("PDFCheckBox")
        self.PDF3CheckBox.setText("Сгенерировать PDF файлы")
        self.PDF3CheckBox.setVisible(False)

        self.spinBox_N.textChanged.connect(self.check_fields)
        self.lineEdit_lambda.textChanged.connect(self.check_fields)
        self.lineEdit_beta.textChanged.connect(self.check_fields)
        self.lineEdit_eps.textChanged.connect(self.check_fields)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Генератор задач"))
        self.comboBox.setItemText(0, _translate("MainWindow", "Задача стационарного распределения"))
        self.comboBox.setItemText(1, _translate("MainWindow", "Задача динамического программирования"))
        self.comboBox.setItemText(2, _translate("MainWindow", "Задача численной оптимизации"))
        self.label.setText(_translate("MainWindow",
                                      "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Задача:</span></p></body></html>"))
        self.label_2.setText(_translate("MainWindow",
                                        "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Количество вариантов:</span></p></body></html>"))
        self.label_3.setText(_translate("MainWindow",
                                        "<html><head/><body><p><span style=\" font-size:12pt; font-weight:500;\">Директория:</span></p></body></html>"))
        self.pushButton.setText(_translate("MainWindow", "Browse"))
        self.pushButton_2.setText(_translate("MainWindow", "OK"))

    def browse_folder(self):
        directory = QFileDialog.getExistingDirectory(None, "Select Directory")
        if directory:
            self.lineEdit_2.setText(directory)

    def on_combobox_changed(self):
        task = self.comboBox.currentText()
        if task == "Задача стационарного распределения":
            self.label_4.setVisible(True)
            self.spinBox.setVisible(True)
            self.label_5.setVisible(False)
            self.columnsSpinBox.setVisible(False)
            self.label_6.setVisible(False)
            self.rowsSpinBox.setVisible(False)
            self.PDF2CheckBox.setVisible(False)
            self.PDF3CheckBox.setVisible(False)
            self.label_7.setVisible(False)
            self.spinBox_N.setVisible(False)
            self.label_eps.setVisible(False)
            self.lineEdit_eps.setVisible(False)
            self.label_beta.setVisible(False)
            self.lineEdit_beta.setVisible(False)
            self.label_lambda.setVisible(False)
            self.lineEdit_lambda.setVisible(False)
        elif task == "Задача динамического программирования":
            self.label_4.setVisible(False)
            self.spinBox.setVisible(False)
            self.label_5.setVisible(True)
            self.columnsSpinBox.setVisible(True)
            self.label_6.setVisible(True)
            self.rowsSpinBox.setVisible(True)
            self.PDF2CheckBox.setVisible(True)
            self.PDF3CheckBox.setVisible(False)
            self.label_7.setVisible(False)
            self.spinBox_N.setVisible(False)
            self.label_eps.setVisible(False)
            self.lineEdit_eps.setVisible(False)
            self.label_beta.setVisible(False)
            self.lineEdit_beta.setVisible(False)
            self.label_lambda.setVisible(False)
            self.lineEdit_lambda.setVisible(False)
        elif task == "Задача численной оптимизации":
            self.label_4.setVisible(False)
            self.spinBox.setVisible(False)
            self.label_5.setVisible(False)
            self.columnsSpinBox.setVisible(False)
            self.label_6.setVisible(False)
            self.rowsSpinBox.setVisible(False)
            self.PDF2CheckBox.setVisible(False)
            self.PDF3CheckBox.setVisible(True)
            self.label_7.setVisible(True)
            self.spinBox_N.setVisible(True)
            self.label_eps.setVisible(True)
            self.lineEdit_eps.setVisible(True)
            self.label_beta.setVisible(True)
            self.lineEdit_beta.setVisible(True)
            self.label_lambda.setVisible(True)
            self.lineEdit_lambda.setVisible(True)
        self.check_fields()

    def check_fields(self):
        task = self.comboBox.currentText()
        if task == "Задача стационарного распределения":
            if self.spinBox_vars.value() > 0 and self.lineEdit_2.text() and self.spinBox.value() > 0:
                self.pushButton_2.setVisible(True)
            else:
                self.pushButton_2.setVisible(False)
        elif task == "Задача динамического программирования":
            if self.spinBox_vars.value() > 0 and self.lineEdit_2.text() and self.columnsSpinBox.value() > 0 and self.rowsSpinBox.value() > 0:
                self.pushButton_2.setVisible(True)
            else:
                self.pushButton_2.setVisible(False)
        elif task == "Задача численной оптимизации":
            if self.lineEdit_2.text() and self.lineEdit_eps.text() and self.lineEdit_beta.text() and self.lineEdit_lambda.text():
                self.pushButton_2.setVisible(True)
            else:
                self.pushButton_2.setVisible(False)
        else:
            self.pushButton_2.setVisible(False)

    def show_message_box(self, text):
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Information)
        msg.setText(text)
        msg.setWindowTitle("Сообщение")
        msg.setStandardButtons(QMessageBox.Ok)
        msg.exec_()

    def run_task(self):
        task = self.comboBox.currentText()
        if task == "Задача стационарного распределения":
            size = self.spinBox.value()
            num_variants = self.spinBox_vars.value()
            directory = self.lineEdit_2.text()
            matrices = save_matrices_to_pdf(num_variants, size, directory)
            save_distributions_to_pdf(matrices, directory)
            save_matrices_to_tex(num_variants, size, matrices, directory)
            save_distributions_to_tex(num_variants, size, matrices, directory)
        elif task == "Задача динамического программирования":
            n = self.rowsSpinBox.value()
            m = self.columnsSpinBox.value()
            directory = self.lineEdit_2.text()
            M = self.spinBox_vars.value()  # Number of variants
            variants = [generate_numbers(n, m) for _ in range(M)]
            solutions = [max_probability_allocation(n, m, variant) for variant in variants]
            latex_content_without_solution = create_latex_document(variants, solutions, n, m, with_solution=False)
            save_latex_file(f"{directory}/tasks_only.tex", latex_content_without_solution)
            if self.PDF2CheckBox.isChecked():
                compile_latex_to_pdf(f"{directory}/tasks_only.tex", directory)
            latex_content_with_solution = create_latex_document(variants, solutions, n, m, with_solution=True)
            save_latex_file(f"{directory}/tasks_with_solutions.tex", latex_content_with_solution)
            if self.PDF2CheckBox.isChecked():
                compile_latex_to_pdf(f"{directory}/tasks_with_solutions.tex", directory)
        elif task == 'Задача численной оптимизации':
            N = self.spinBox_N.value()
            num_variants = self.spinBox_vars.value()  # задано
            try:
                epsilon = float(self.lineEdit_eps.text())  # задано
                beta = float(self.lineEdit_beta.text())  # задано
                lambda_ = float(self.lineEdit_lambda.text())  # задано
            except ValueError:
                self.show_message_box(text='Введите численное значение для eps, beta и lambda (разделитель - точка)')
                return
            directory = self.lineEdit_2.text()

            variants = [[generate_positive_definite_matrix(N) for _ in range(num_variants)],
                        [generate_a(N) for _ in range(num_variants)]]
            solutions = []

            for W, a in zip(variants[0], variants[1]):
                print(f"Generated matrix W:\n{W}\n")
                print(f"Generated a :\n{a}\n")
                x0 = np.round(np.random.rand(N), 3)
                print(f"Initial point x0: {x0}\n")

                result = minimize(f, x0, args=(W, a))
                minimum_x = result.x
                minimum_value = result.fun

                print(f"Minimum found by built-in function at point: {minimum_x}")
                print(f"Value of the function at this point: {minimum_value}\n")

                start_point = minimum_x + np.random.normal(0, 0.1, size=minimum_x.shape)
                final_x, final_value, num_iterations = gradient_descent(f, start_point, W, a, epsilon, beta, lambda_)

                print(f"Minimum found by gradient descent at point: {final_x}")
                print(f"Value of the function at this point: {final_value}")
                print(f"Number of iterations: {num_iterations}\n")

                solutions.append((minimum_x, minimum_value, final_x, final_value, num_iterations, x0))

            latex_content_without_solution = create_latex_document_new(variants, solutions, N, epsilon, beta, lambda_,
                                                                   with_solution=False)
            save_latex_file_new(f"{directory}/tasks.tex", latex_content_without_solution)

            if self.PDF3CheckBox.isChecked():
                compile_latex_to_pdf_new(f"{directory}/tasks.tex")

            latex_content_with_solution = create_latex_document_new(variants, solutions, N, epsilon, beta, lambda_,
                                                                with_solution=True)
            save_latex_file_new(f"{directory}/solutions.tex", latex_content_with_solution)

            if self.PDF2CheckBox.isChecked():
                compile_latex_to_pdf_new(f"{directory}/solutions.tex")

        self.show_message_box(text="Файлы успешно сгенерированы")


'''Stationary Distribution'''


def generate_random_fraction_matrix(size, denominator=20):
    matrix = np.zeros((size, size), dtype=object)

    for i in range(size):
        random_points = sorted(np.random.choice(range(1, denominator), size - 1, replace=False))
        numerators = [random_points[0]] + [random_points[j] - random_points[j-1] for j in range(1, size - 1)] + [denominator - random_points[-1]]

        row = [Fraction(num, denominator) for num in numerators]
        matrix[i] = row

    return matrix


def find_stationary_distribution(P, max_denominator=20):
    size = len(P)
    P_float = np.array(P, dtype=float)
    A = P_float.T - np.eye(size)
    A = np.vstack([A, np.ones(size)])
    b = np.zeros(size + 1)
    b[-1] = 1

    pi = np.linalg.lstsq(A, b, rcond=None)[0]
    stationary_vector = [Fraction.from_float(v).limit_denominator() for v in pi]

    return stationary_vector


def save_matrices_to_pdf(num_variants, size, directory, max_denominator=20):
    pdf = FPDF()
    pdf.add_page()
    pdf.add_font("DejaVu", "", "font/DejavuSans.ttf", uni=True)
    pdf.set_font("DejaVu", size=12)

    matrices = []

    for i in range(num_variants):
        P = generate_random_fraction_matrix(size, denominator=20)
        matrices.append(P)
        pdf.cell(200, 10, text=f"Вариант # {i+1}", new_x="LMARGIN", new_y="NEXT")
        pdf.multi_cell(200, 10, text="Найти стационарное распределение однородной цепи Маркова в дискретном времени с матрицей перехода", new_x="LMARGIN", new_y="NEXT")
        for row in P:
            row_text = ' '.join([str(elem) for elem in row])
            pdf.cell(200, 10, text=row_text, new_x="LMARGIN", new_y="NEXT")
        pdf.cell(200, 10, text="", new_x="LMARGIN", new_y="NEXT")
        pdf.cell(0, 10, "", new_x="LMARGIN", new_y="NEXT", border='B')

    pdf.output(f"{directory}/transition_matrices.pdf")
    return matrices


def save_distributions_to_pdf(matrices, directory, max_denominator=20):
    pdf = FPDF()
    pdf.add_page()
    pdf.add_font("DejaVu", "", "font/DejavuSans.ttf", uni=True)
    pdf.set_font("DejaVu", size=12)

    for i, P in enumerate(matrices):
        pi = find_stationary_distribution(P, max_denominator=max_denominator)
        pdf.cell(200, 10, text=f"Вариант # {i+1}", new_x="LMARGIN", new_y="NEXT")
        pdf.cell(200, 10, text=f"Стационарное распределение:", new_x="LMARGIN", new_y="NEXT")
        pi_text = ' '.join([str(elem) for elem in pi])
        pdf.cell(200, 10, text=pi_text, new_x="LMARGIN", new_y="NEXT")
        pdf.cell(200, 10, text="", new_x="LMARGIN", new_y="NEXT")

    pdf.output(f"{directory}/transition_matrices_with_distributions.pdf")


def save_matrices_to_tex(num_variants, size, matrices, directory):
    with open(f"{directory}/transition_matrices.tex", "w") as f:
        f.write(r"\documentclass{article}" + "\n")
        f.write(r"\usepackage[utf8]{inputenc}" + "\n")
        f.write(r"\usepackage[russian]{babel}" + "\n")
        f.write(r"\usepackage{amsmath}" + "\n")
        f.write(r"\begin{document}" + "\n")

        for i in range(num_variants):
            P = matrices[i]
            f.write(f"\\section*{{Вариант # {i+1}}}\n")
            f.write("Найти стационарное распределение однородной цепи Маркова в дискретном времени с матрицей перехода:\n")
            f.write("\\begin{equation}\n")
            f.write("\\left( \\begin{array}{" + "c" * size + "}\n")
            for row in P:
                row_text = ' & '.join([str(elem) for elem in row])
                f.write(row_text + r" \\" + "\n")
            f.write("\\end{array} \\right)\n")
            f.write("\\end{equation}\n")
            f.write("\\noindent\\rule{\\textwidth}{0.4pt}\n")

        f.write(r"\end{document}" + "\n")


def save_distributions_to_tex(num_variants, size, matrices, directory):
    with open(f"{directory}/transition_matrices_with_distributions.tex", "w") as f:
        f.write(r"\documentclass{article}" + "\n")
        f.write(r"\usepackage[utf8]{inputenc}" + "\n")
        f.write(r"\usepackage[russian]{babel}" + "\n")
        f.write(r"\usepackage{amsmath}" + "\n")
        f.write(r"\begin{document}" + "\n")

        for i in range(num_variants):
            P = matrices[i]
            pi = find_stationary_distribution(P)
            f.write(f"\\section*{{Вариант # {i+1}}}\n")
            f.write("\\noindent Стационарное распределение:\\\\\n")
            f.write("\\begin{equation}\n")
            f.write(" \\left( \\begin{array}{c}\n")
            pi_text = '\quad'.join([str(elem) for elem in pi])
            f.write(pi_text + r" \\" + "\n")
            f.write("\\end{array} \\right)\n")
            f.write("\\end{equation}\n")
            f.write("\\noindent\\rule{\\textwidth}{0.4pt}\n")

        f.write(r"\end{document}" + "\n")


'''Dynamic Programming'''


def generate_numbers(n, m):
    numbers = []
    for i in range(n):
        sequence = sorted([round(random.uniform(0, 1), 1) for _ in range(m)], reverse=True)
        numbers.extend(sequence)
    return numbers


def max_probability_allocation(n, m, probabilities):
    num_machines = m
    num_companies = n
    probabilities = np.array(probabilities).reshape(num_companies, num_machines)
    dp = np.zeros((num_companies + 1, num_machines + 1))
    dp[0, 0] = 1
    choices = [[[] for _ in range(num_machines + 1)] for _ in range(num_companies + 1)]
    for i in range(1, num_companies + 1):
        for j in range(num_machines + 1):
            for k in range(min(j, num_machines) + 1):
                prob = dp[i - 1, j - k] * (probabilities[i - 1, k - 1] if k > 0 else 1)
                if prob > dp[i, j]:
                    dp[i, j] = prob
                    choices[i][j] = [[k]]
                elif prob == dp[i, j]:
                    choices[i][j].append([k])

    def get_all_allocations(i, j):
        if i == 0:
            return [[]]
        all_paths = []
        for choice in choices[i][j]:
            sub_paths = get_all_allocations(i - 1, j - choice[0])
            for sub_path in sub_paths:
                all_paths.append(sub_path + choice)
        return all_paths

    all_allocations = get_all_allocations(num_companies, num_machines)
    unique_allocations = []
    for alloc in all_allocations:
        if alloc not in unique_allocations:
            unique_allocations.append(alloc)
    solution_text = ""
    solution_text += "Матрица вероятностей:\n"
    solution_text += str(probabilities)
    solution_text += "\n\nОптимальные распределения машин по каждой компании (в порядке от первой до последней):\n"
    for alloc in unique_allocations:
        solution_text += str(alloc) + "\n"
    solution_text += f"\nМаксимальная вероятность выполнения заказа: {dp[num_companies, num_machines]:.5f}\n"
    return solution_text


def create_latex_table(numbers, n, m):
    latex = "\\begin{center}\n"
    latex += "\\begin{tabular}{|" + "c|" * (m + 1) + "}\n"
    latex += "\\hline\n"
    headers = " & " + " & ".join([str(i + 1) for i in range(m)]) + " \\\\ \\hline\n"
    latex += headers
    for i in range(n):
        row = " & ".join(map(str, numbers[i * m:(i + 1) * m])) + f" \\\\ \\hline\n"
        latex += f"$P_{{{i + 1}}}$ & " + row
    latex += "\\end{tabular}\n"
    latex += "\\end{center}\n"
    return latex


def create_latex_document(variants, solutions, n, m, with_solution=False):
    latex = "\\documentclass{article}\n"
    latex += "\\usepackage[utf8]{inputenc}\n"
    latex += "\\usepackage[russian]{babel}\n"
    latex += "\\usepackage{geometry}\n"
    latex += "\\usepackage{amsmath}\n"
    latex += "\\usepackage{graphicx}\n"
    latex += "\\geometry{a4paper, margin=1in}\n"
    latex += "\\begin{document}\n"
    for i, numbers in enumerate(variants):
        latex += f"\\section*{{Вариант № {i + 1}}}\n"
        latex += f"Срочный заказ по изготовлению {m} машин необходимо разместить между {n} предприятиями. "
        latex += f"Вероятности выполнения заказа $k$-ым предприятием равны $P_k$ (где $k$ - это индекс) зависят от величины заказа и заданы таблицей.\n"
        latex += create_latex_table(numbers, n, m)
        latex += f"\nНайти оптимальный план размещения заказа, при котором достигает максимум вероятность $P$ выполнения заказа всеми предприятиями.\n"
        if with_solution:
            latex += "\n\\textbf{Решение:}\n"
            latex += solutions[i].replace("\n", "\\newline\n")
        if i < len(variants) - 1:
            latex += "\\newpage\n"
    latex += "\\end{document}\n"
    return latex


def save_latex_file(filename, content):
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(content)


def compile_latex_to_pdf(latex_filename, output_directory):
    result = subprocess.run(["pdflatex", f"-output-directory={output_directory}", latex_filename], capture_output=True, text=True)
    if result.returncode != 0:
        print("Error during LaTeX compilation:")
        print(result.stderr)
        with open("error.log", 'w') as f:
            f.write(result.stderr)
    else:
        print("PDF file created successfully.")


'''Task 3'''


def generate_non_singular_matrix(N):
    while True:
        matrix = np.random.randint(-6, 7, (N, N))
        if np.linalg.det(matrix) != 0:
            return matrix


def transpose_and_multiply(matrix):
    transpose = matrix.T
    product = np.dot(matrix, transpose)
    return transpose, product


def scale_and_round(matrix):
    scaled_matrix = np.round(matrix / 10).astype(int)
    return scaled_matrix


def is_positive_definite(matrix):
    return np.all(np.linalg.eigvals(matrix) > 0)


def generate_positive_definite_matrix(N):
    while True:
        matrix = generate_non_singular_matrix(N)
        transpose, product = transpose_and_multiply(matrix)
        final_matrix = scale_and_round(product)
        if is_positive_definite(final_matrix):
            return final_matrix


def f(x, W, a):
    return x.T @ W @ x + (x - a).T @ (x - a)


def gradient(f, x, W, a):
    grad = np.zeros_like(x)
    h = 1e-5
    for i in range(len(x)):
        x_h1 = np.copy(x)
        x_h2 = np.copy(x)
        x_h1[i] += h
        x_h2[i] -= h
        grad[i] = (f(x_h1, W, a) - f(x_h2, W, a)) / (2 * h)
    return grad


def gradient_descent(f, x0, W, a, epsilon, beta, lambda_):
    x = np.copy(x0)
    num_iterations = 0
    while True:
        grad = gradient(f, x, W, a)
        if np.max(np.abs(grad)) < epsilon:
            break
        t = beta
        while f(x - t * grad, W, a) > f(x, W, a):
            t *= lambda_
        x = x - t * grad
        num_iterations += 1
    return x, f(x, W, a), num_iterations


def create_latex_table_new(W, a):
    N = W.shape[0]
    latex = "\\begin{align*}\n"
    latex += f"f({', '.join(f'x_{{{j + 1}}}' for j in range(N))}) &= "
    linear_terms = [0] * N
    free_term = 0
    first_term = True
    line_length = 0

    def add_term(term):
        nonlocal latex, line_length, first_term
        if line_length + len(term) > 80:
            latex += " \\\\ \n& "
            line_length = 0
        if not first_term:
            latex += f" + {term}" if term[0] != '-' else f" {term}"
        else:
            latex += term
            first_term = False
        line_length += len(term)

    for i in range(N):
        for j in range(i, N):
            coef = W[i, j]
            if i == j:
                term = f"{coef + 1}x_{{{i + 1}}}^2"
            else:
                term = f"{2 * coef}x_{{{i + 1}}}x_{{{j + 1}}}"

            if coef != 0:
                add_term(term)

    for i in range(N):
        linear_terms[i] -= 2 * a[i]
        free_term += a[i] ** 2

    for i in range(N):
        if linear_terms[i] != 0:
            term = f"{linear_terms[i]}x_{{{i + 1}}}"
            add_term(term)

    if free_term != 0:
        add_term(f"{free_term}")

    latex += "\n\\end{align*}\n"
    return latex


def create_latex_document_new(variants, solutions, N, epsilon, beta, lambda_, with_solution=False):
    latex = "\\documentclass{article}\n"
    latex += "\\usepackage[utf8]{inputenc}\n"
    latex += "\\usepackage[russian]{babel}\n"
    latex += "\\usepackage{amsmath}\n"
    latex += "\\usepackage{geometry}\n"
    latex += "\\geometry{a4paper, margin=1in}\n"
    latex += "\\begin{document}\n"

    variant_pairs = list(zip(variants[0], variants[1]))

    for i, ((W, a), (minimum_x, minimum_value, final_x, final_value, num_iterations, x0)) in enumerate(
            zip(variant_pairs, solutions)):
        latex += f"\\section*{{\\textbf{{Вариант № {i + 1}}}}}\n"
        latex += "{Найти минимум функции:}\n"
        latex += create_latex_table_new(W, a)
        latex += "методом градиентного спуска с дроблением шага.\n"
        latex += "\\newline\n"
        latex += "В качестве начального приближения взять:\n"
        latex += "$$\n"
        latex += "\\begin{bmatrix}\n"
        latex += "\\\\\n".join(f"x_{{{j + 1}}}" for j in range(N)) + "\n"
        latex += "\\end{bmatrix}\n"
        latex += " = \n"
        latex += "\\begin{bmatrix}\n"
        latex += "\\\\\n".join(map(str, x0)) + "\n"
        latex += "\\end{bmatrix}\n"
        latex += "$$\n"
        latex += f"В качестве точности вычисления взять $\\varepsilon = {epsilon}.$\n"
        latex += "\\newline\n"
        latex += "В качестве критерия остановки:\n"
        latex += "$$\n"
        latex += "\\max\\limits_{1 \\leq j \\leq n} \\left| \\frac{\\partial f_0 (x^k)}{\\partial x_j} \\right| < \\varepsilon.\n"
        latex += "$$\n"
        latex += f"В качестве начальной длины шага взять $\\beta = {beta}.$\n"
        latex += "\\newline\n"
        latex += f"В качестве коэффициента дробления $\\lambda = {lambda_}.$\n"
        latex += "\\newline\n"

        if with_solution:
            latex += "\\textbf{Решение:}\n"
            latex += "\\newline\n"
            latex += "Минимум найден встроенной функцией в точке:\n"
            latex += "$$\n"
            latex += "\\begin{bmatrix}\n"
            latex += "\\\\\n".join(map(str, minimum_x)) + "\n"
            latex += "\\end{bmatrix}\n"
            latex += "$$\n"
            latex += f"Значение функции в точке:\n {minimum_value}.\n"
            latex += "\\newline\n"
            latex += "Минимум найденный методом градиентного спуска в точке:\n"
            latex += "$$\n"
            latex += "\\begin{bmatrix}\n"
            latex += "\\\\\n".join(map(str, final_x)) + "\n"
            latex += "\\end{bmatrix}\n"
            latex += "$$\n"
            latex += f"Значение функции в точке:\n {final_value}.\n"
            latex += "\\newline\n"
            latex += f"Число итераций:\n {num_iterations}.\n"

        if i < len(variants[0]) - 1:
            latex += "\\newpage\n"

    latex += "\\end{document}\n"
    return latex


def save_latex_file_new(filename, content):
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(content)


def compile_latex_to_pdf_new(latex_filename):
    result = subprocess.run(["pdflatex", latex_filename], capture_output=True, text=True)
    if result.returncode != 0:
        print("Error during LaTeX compilation:")
        print(result.stderr)
        with open("error.log", 'w') as f:
            f.write(result.stderr)
    else:
        print("PDF file created successfully.")


def generate_a(N):
    return np.random.randint(-10, 11, N)


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())

